---------------------------------------------------------------
-- Copyright (C) 2024-2026 Frode Randers
-- All rights reserved
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--    http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
---------------------------------------------------------------

---------------------------------------------------------------
-- Database schema: PostgreSQL
--
-- Remember to grant privileges to the specific database user
---------------------------------------------------------------

CREATE SCHEMA IF NOT EXISTS repo AUTHORIZATION repo;

ALTER ROLE repo SET search_path = repo, public;

---------------------------------------------------------------
-- Identifies tenants for information units
--
CREATE TABLE repo_tenant (
    tenantid    INT       NOT NULL, -- id of tenant

    name        TEXT      NOT NULL, -- name of tenant
    description TEXT,               -- description of tenant
    created     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_tenant_pk
        PRIMARY KEY (tenantid),
    CONSTRAINT repo_tenant_name_unique
        UNIQUE (name)
);


---------------------------------------------------------------
-- Unit entities
--
CREATE TABLE repo_unit_kernel (
    tenantid     INT       NOT NULL,                      -- id of tenant
    unitid       BIGINT GENERATED BY DEFAULT AS IDENTITY, -- id of unit

    corrid       UUID      NOT NULL,                      -- UUID v7 (if not provided)
    status       INT       NOT NULL DEFAULT 30,           -- See Unit.Status
    lastver      INT       NOT NULL DEFAULT 1,            -- last version of this unit
    created      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_unit_kernel_pk
        PRIMARY KEY (tenantid, unitid),
    CONSTRAINT repo_uk_corrid_unique
        UNIQUE (corrid),
    CONSTRAINT repo_unit_kernel_tenant_exists
        FOREIGN KEY (tenantid) REFERENCES repo_tenant (tenantid)
);

CREATE INDEX repo_uk_ind1
    ON repo_unit_kernel (tenantid, status, created DESC)
    INCLUDE (unitid, lastver);

CREATE INDEX repo_uk_ind2
    ON repo_unit_kernel (tenantid, unitid, lastver);

CREATE TABLE repo_unit_version (
    tenantid     INT        NOT NULL,  -- id of tenant
    unitid       BIGINT     NOT NULL,  -- id of unit
    unitver      INTEGER    NOT NULL,  -- version of unit

    unitname     VARCHAR(255),         -- name of unit
    modified     TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_unit_version_pk
        PRIMARY KEY (tenantid, unitid, unitver),
    CONSTRAINT repo_unit_version_krnl_exists
        FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit_kernel (tenantid, unitid) ON DELETE CASCADE
);

CREATE INDEX repo_uv_ind1
    ON repo_unit_version (tenantid, unitid, unitver, modified)
    INCLUDE (unitname);

CREATE INDEX repo_uv_ind2
    ON repo_unit_version (tenantid, LOWER(unitname), unitid, unitver);


/*
 * Could be of interest
 *
CREATE VIEW repo_unit_last_version AS
SELECT uk.tenantid, uk.unitid, uv.unitver, uk.corrid, uk.status, uv.unitname, uk.lastver, uk.created, uv.modified
FROM repo_unit_kernel uk
    JOIN repo_unit_version uv ON
         uk.tenantid = uv.tenantid
     AND uk.unitid = uv.unitid
     AND uk.lastver = uv.unitver;
*/

---------------------------------------------------------------
-- Collection of known attributes
--
CREATE TABLE repo_namespace (
    alias     TEXT NOT NULL,  -- alias of namespace
    namespace TEXT NOT NULL,  -- namespace of attribute

    CONSTRAINT repo_namespace_pk
        PRIMARY KEY (alias, namespace)
);

CREATE TABLE repo_attribute (
    attrid      INT GENERATED BY DEFAULT AS IDENTITY,  -- id of attribute (serial)

    qualname    TEXT      NOT NULL,  -- qualified name of attribute
    attrname    TEXT      NOT NULL,  -- name of attribute
    alias       TEXT      NULL,      -- optional alias of attribute
    attrtype    INT       NOT NULL,  -- defined in org.gautelis.repo.model.attributes.Type
    scalar      BOOLEAN   NOT NULL DEFAULT FALSE,
    created     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_attribute_pk
        PRIMARY KEY (attrid),
    CONSTRAINT repo_attr_qualname_unique
        UNIQUE (qualname),
    CONSTRAINT repo_attr_name_unique
        UNIQUE (attrname)
);

CREATE TABLE repo_attribute_description (
    attrid      INT     NOT NULL,  -- id of attribute (serial)
    lang        CHAR(2) NOT NULL DEFAULT 'SE',

    alias       TEXT    NOT NULL,  -- translated name of attribute
    description TEXT,              -- description of attribute

    CONSTRAINT repo_attribute_description_pk
        PRIMARY KEY (attrid, lang),
    CONSTRAINT repo_attr_desc_attr_ex
        FOREIGN KEY (attrid) REFERENCES repo_attribute (attrid)
);

---------------------------------------------------------------------------
-- Values of attributes
--
-- CREATE EXTENSION IF NOT EXISTS btree_gist;

CREATE TABLE repo_attribute_value (
    tenantid INT    NOT NULL,  -- id of tenant
    unitid   BIGINT NOT NULL,  -- id of unit
    attrid   INT    NOT NULL,  -- id of attribute
    valueid  BIGINT GENERATED BY DEFAULT AS IDENTITY, -- id of attribute (value) instantiation

    unitverfrom INTEGER NOT NULL DEFAULT 1, -- unit version from (inclusive)
    unitverto   INTEGER NOT NULL DEFAULT 1, -- unit version to (inclusive)
    --unitver int4range GENERATED ALWAYS AS (int4range(unitverfrom, unitverto, '[]')) STORED,

    CONSTRAINT repo_attribute_value_pk
        --  covers update and delete by unit
        PRIMARY KEY (tenantid, unitid, attrid, valueid, unitverfrom),
    CONSTRAINT repo_attribute_value_id_unique
        UNIQUE (valueid),
    --CONSTRAINT repo_attribute_value_unitver_no_overlap
    --    EXCLUDE USING gist (
    --        tenantid WITH =,
    --        unitid   WITH =,
    --        attrid   WITH =,
    --        unitver  WITH &&
    --    ),
    CONSTRAINT repo_attribute_value_attr_ex
        FOREIGN KEY (attrid) REFERENCES repo_attribute (attrid),
    CONSTRAINT repo_attribute_value_unit_ex1
        FOREIGN KEY (tenantid, unitid, unitverfrom) REFERENCES repo_unit_version (tenantid, unitid, unitver) ON DELETE CASCADE,
    CONSTRAINT repo_attribute_value_unit_ex2
        FOREIGN KEY (tenantid, unitid, unitverto) REFERENCES repo_unit_version (tenantid, unitid, unitver) ON DELETE CASCADE
);

-- covers attribute search, like "find all units where x = ... or y = ...
CREATE INDEX repo_av_ind1
    ON repo_attribute_value (attrid ASC);

CREATE INDEX repo_av_ind2
    ON repo_attribute_value (tenantid, unitid, attrid, unitverfrom, unitverto)
    INCLUDE (valueid);

/*
 * If we anticipate a lot of versions of units with multiple
 * attribute (value) modifications, the cost of keeping a 'current'
 * representation of attribute values becomes more palatable
 *
CREATE TABLE repo_attribute_current_value (
tenantid int NOT NULL,
unitid   bigint NOT NULL,
attrid   int NOT NULL,
valueid  bigint NOT NULL,

CONSTRAINT repo_attribute_current_value_pk
    PRIMARY KEY (tenantid, unitid, attrid)
);
 */

---------------------------------------------------------------
-- Metadata-table: Unit-template lookup table.
-- The configuration loader inserts one row per @use field in every
-- @template type â€¦.
-- Records  are handled separately in 'repo_record_template'
--
CREATE TABLE repo_unit_template (
templateid INT GENERATED BY DEFAULT AS IDENTITY,

name       TEXT NOT NULL,   -- type name

CONSTRAINT repo_unit_template_pk
    PRIMARY KEY (templateid),
CONSTRAINT repo_unit_template_name_uq
    UNIQUE (name)
);

CREATE TABLE repo_unit_template_elements (
templateid INT  NOT NULL,   --
attrid     INT  NOT NULL,   -- global attribute id

idx        INT  NOT NULL,   -- order / display position
alias      TEXT NOT NULL,   -- field name inside unit (template)

CONSTRAINT repo_unit_template_elements_pk
    PRIMARY KEY (templateid, attrid),
CONSTRAINT repo_unit_template_elements_tmp_ex
    FOREIGN KEY (templateid) REFERENCES repo_unit_template (templateid) ON DELETE CASCADE
);

---------------------------------------------------------------
-- Metadata-table: Template for records
--
CREATE TABLE repo_record_template (
recordid  INT NOT NULL,
name      TEXT NOT NULL, -- type name

CONSTRAINT repo_record_template_pk
    PRIMARY KEY (recordid),
CONSTRAINT repo_record_template_name_uq
    UNIQUE (name),
CONSTRAINT repo_record_template_id_ex
    FOREIGN KEY (recordid) REFERENCES repo_attribute(attrid)
);

CREATE TABLE repo_record_template_elements (
recordid    INT  NOT NULL,      -- attribute id of record attribute
attrid      INT  NOT NULL,      -- sub-attribute

idx         INT  NOT NULL,      -- order / display position
alias       TEXT NULL,          -- field name inside record

CONSTRAINT repo_record_template_elements_pk
    PRIMARY KEY (recordid, attrid),
CONSTRAINT repo_record_template_elements_id_ex
    FOREIGN KEY (attrid) REFERENCES repo_attribute(attrid),
CONSTRAINT repo_record_template_elements_rcrd_ex
    FOREIGN KEY (recordid) REFERENCES repo_record_template (recordid) ON DELETE CASCADE
);


---------------------------------------------------------------
-- Attribute value vectors
--
-- String values
--
CREATE TABLE repo_string_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value (serial)
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    TEXT,

CONSTRAINT repo_string_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_string_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

-- Considering removing
CREATE INDEX repo_sv_ind1
ON repo_string_vector (LOWER(value) ASC);

-- Considering... for ILIKE '%foo%' searches
-- CREATE EXTENSION IF NOT EXISTS pg_trgm;
--
-- CREATE INDEX repo_sv_val_trgm ON repo_string_vector
--     USING gin (lower(val) gin_trgm_ops);

-- Considering attribute-targeted partial indexes, e.g. attribute "dcterms:title" with attrid = 1
-- CREATE INDEX repo_sv_title_trgm ON repo_string_vector
--    USING gin (lower(val) gin_trgm_ops)
--    WHERE valueid IN (SELECT valueid FROM repo_attribute_value WHERE attrid = 1);

--
-- Date values
--
CREATE TABLE repo_time_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    TIMESTAMP,

CONSTRAINT repo_time_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_time_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

-- Relevant for range scans (x <= ?)
CREATE INDEX repo_tiv_ind1
    ON repo_time_vector (value ASC);

--
-- Integer values
--
CREATE TABLE repo_integer_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    INT,

CONSTRAINT repo_integer_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_integer_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

--
-- Long values
--
CREATE TABLE repo_long_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    BIGINT,

CONSTRAINT repo_long_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_long_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

--
-- Double values
--
CREATE TABLE repo_double_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    DOUBLE PRECISION,

CONSTRAINT repo_double_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_double_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

--
-- Boolean values
--
CREATE TABLE repo_boolean_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    BOOLEAN,

CONSTRAINT repo_boolean_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_boolean_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

--
-- Binary values
--
CREATE TABLE repo_data_vector (
valueid  BIGINT NOT NULL,           -- id of attribute value
idx      INT    NOT NULL DEFAULT 0, -- index of value

value    BYTEA,

CONSTRAINT repo_data_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_data_v_value_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

--
-- Records
-- TODO: Considering adding ref_attrid to PK, if the same sub-vector appears more than once in parent.
CREATE TABLE repo_record_vector (
valueid     BIGINT NOT NULL,           -- parent value vector
idx         INT    NOT NULL DEFAULT 0, -- position within parent

ref_attrid  INT    NOT NULL,
ref_valueid BIGINT NULL,               -- initially null when first written, later updated

CONSTRAINT repo_record_vector_pk
    PRIMARY KEY (valueid, idx),
CONSTRAINT repo_record_vec_parent_ex
    FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE,
CONSTRAINT repo_record_vec_child_ex
    FOREIGN KEY (ref_valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
);

-- Relevant when resolving placeholders (child -> parent),
-- i.e. when querying "WHERE ref_valueid = ?child?"
CREATE INDEX repo_rv_ind1
ON repo_record_vector (ref_valueid)
WITH (fillfactor = 80); -- 80-90% is a reasonable starting point for ensuring enough head-room for page splits during steady ingest


-- Relevant when deleting a child, validating schema, adding a composite
CREATE INDEX repo_rv_ind2
ON repo_record_vector (valueid, ref_attrid);


---------------------------------------------------------------
-- The log
--
CREATE TABLE repo_log (
tenantid  INT       NOT NULL,
unitid    BIGINT    NOT NULL,
unitver   INTEGER   NOT NULL,
event     INT       NOT NULL, -- defined in org.gautelis.repo.model.ActionEvent
logentry  TEXT      NOT NULL,
logtime   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- When searching for all events for a certain unit
CREATE INDEX repo_log_ind1
ON repo_log (tenantid, unitid);



---------------------------------------------------------------
-- Unit locks
--
-- The 'type' may have one of these values
--   10 - read lock
--   20 - existence lock
--   30 - write lock
--
-- Severity/guarantee: 10 < 20 < 30
--
CREATE TABLE repo_lock (
tenantid INT        NOT NULL,
unitid   BIGINT     NOT NULL,
lockid   BIGINT GENERATED ALWAYS AS IDENTITY,

purpose  TEXT       NOT NULL,
locktype INT        NOT NULL,
expire   TIMESTAMP,
locktime TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP,

CONSTRAINT repo_lock_pk
    PRIMARY KEY (tenantid, unitid, lockid),
CONSTRAINT repo_lock_unit_exists
    FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit_kernel (tenantid, unitid) ON DELETE CASCADE
);


----------------------------------------------------------------
-- Associations functionality
--
-- Internal relations describe relations between units
-- (of various types) in the archive.
--
-- External associations describe associations between a unit
-- and a resource in any external system where the resource is
-- uniquely identified by a string.
--
CREATE TABLE repo_internal_relation (
tenantid     INT       NOT NULL,
unitid       BIGINT    NOT NULL,
reltype      INT       NOT NULL,
reltenantid  INT       NOT NULL,
relunitid    BIGINT    NOT NULL,
created      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

CONSTRAINT repo_internal_relation_pk
    PRIMARY KEY (tenantid, unitid, reltype, reltenantid, relunitid),
CONSTRAINT repo_ir_left_unit_exists
    FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit_kernel (tenantid, unitid) ON DELETE CASCADE,
CONSTRAINT repo_ir_right_unit_exists
    FOREIGN KEY (reltenantid, relunitid) REFERENCES repo_unit_kernel (tenantid, unitid) ON DELETE CASCADE
);

CREATE INDEX repo_irelation_idx1
ON repo_internal_relation (reltype, reltenantid, relunitid);

CREATE INDEX repo_irelation_idx2
ON repo_internal_relation (tenantid, unitid, reltype);

CREATE TABLE repo_external_assoc (
tenantid    INT       NOT NULL,
unitid      BIGINT    NOT NULL,
assoctype   INT       NOT NULL,
assocstring TEXT      NOT NULL,
created     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

CONSTRAINT repo_external_assoc_pk
    PRIMARY KEY (tenantid, unitid, assoctype, assocstring),
CONSTRAINT repo_ea_left_unit_exists
    FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit_kernel (tenantid, unitid) ON DELETE CASCADE
);

CREATE INDEX repo_eassoc_idx1
ON repo_external_assoc (assoctype, assocstring);

CREATE INDEX repo_eassoc_idx2
ON repo_external_assoc (tenantid, unitid, assoctype);
