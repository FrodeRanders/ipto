---------------------------------------------------------------
-- Copyright (C) 2024-2025 Frode Randers
-- All rights reserved
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--    http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
---------------------------------------------------------------

---------------------------------------------------------------
-- Database schema: PostgreSQL
--
-- Remember to grant privileges to the specific database user
---------------------------------------------------------------

CREATE SCHEMA IF NOT EXISTS repo AUTHORIZATION repo
;

ALTER ROLE repo SET search_path = repo, public
;

---------------------------------------------------------------
-- Identifies tenants for information units
--
CREATE TABLE repo_tenant (
    tenantid    INT       NOT NULL, -- id of tenant

    name        TEXT      NOT NULL, -- name of tenant
    description TEXT,               -- description of tenant
    created     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_tenant_pk
        PRIMARY KEY (tenantid),
    CONSTRAINT repo_tenant_name_unique
        UNIQUE (name)
)
;


---------------------------------------------------------------
-- Unit entities
--
CREATE TABLE repo_unit (
    tenantid INT       NOT NULL,                      -- id of tenant
    unitid   BIGINT GENERATED BY DEFAULT AS IDENTITY, -- id of unit

    corrid   CHAR(36)  NOT NULL,                      -- UUID v7 (if not provided)
    name     TEXT      NOT NULL,                      -- name of unit
    status   INT       NOT NULL DEFAULT 30,           -- See Unit.Status
    created  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_unit_pk
        PRIMARY KEY (tenantid, unitid),
    CONSTRAINT repo_uk_corrid_unique
        UNIQUE (corrid),
    CONSTRAINT repo_unit_tenant_exists
        FOREIGN KEY (tenantid) REFERENCES repo_tenant (tenantid)
)
;

CREATE INDEX repo_ut_ind1 ON repo_unit (
    tenantid, status, created DESC
) INCLUDE (unitid, name);

---------------------------------------------------------------
-- Collection of known attributes
--
CREATE TABLE repo_namespace (
    alias     TEXT NOT NULL, -- alias of namespace
    namespace TEXT NOT NULL, -- namespace of attribute

    CONSTRAINT repo_namespace_pk
        PRIMARY KEY (alias, namespace)
)
;

CREATE TABLE repo_attribute (
    attrid      INT       NOT NULL,           -- id of attribute (serial)

    qualname    TEXT      NOT NULL,           -- qualified name of attribute
    attrname    TEXT      NOT NULL,           -- name of attribute
    attrtype    INT       NOT NULL,           -- defined in org.gautelis.repo.model.attributes.Type
    scalar      BOOLEAN   NOT NULL DEFAULT FALSE,
    created     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_attribute_pk
        PRIMARY KEY (attrid),
    CONSTRAINT repo_attr_qualname_unique
        UNIQUE (qualname),
    CONSTRAINT repo_attr_name_unique
        UNIQUE (attrname)
)
;

CREATE TABLE repo_attribute_description (
    attrid      INT     NOT NULL,               -- id of attribute (serial)
    lang        CHAR(2) NOT NULL DEFAULT 'SE',

    alias       TEXT    NOT NULL,               -- translated name of attribute
    description TEXT,                           -- description of attribute

    CONSTRAINT repo_attribute_description_pk
        PRIMARY KEY (attrid, lang),
    CONSTRAINT repo_attr_desc_attr_ex
        FOREIGN KEY (attrid) REFERENCES repo_attribute (attrid)
)
;

---------------------------------------------------------------------------
-- Values of attributes
--
CREATE TABLE repo_attribute_value (
    tenantid INT    NOT NULL,                        -- id of tenant
    unitid   BIGINT NOT NULL,                        -- id of unit
    attrid   INT    NOT NULL,                        -- id of attribute

    valueid  BIGINT GENERATED BY DEFAULT AS IDENTITY, -- id of attribute (value) instantiation

    CONSTRAINT repo_attribute_value_pk
        --  covers update and delete by unit
        PRIMARY KEY (tenantid, unitid, attrid),
    CONSTRAINT repo_attribute_value_id_unique
        UNIQUE (valueid),
    CONSTRAINT repo_attribute_value_attr_ex
        FOREIGN KEY (attrid) REFERENCES repo_attribute (attrid),
    CONSTRAINT repo_attribute_value_unit_ex
        FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit (tenantid, unitid) ON DELETE CASCADE
)
;

-- covers attribute search, like "find all units where x = ... or y = ...
CREATE INDEX repo_av_ind1 ON repo_attribute_value (
     attrid ASC
)
;

---------------------------------------------------------------
-- Metadata-table: Unit-template lookup table.
-- The configuration loader inserts one row per @use field in every type … @unit.
--
CREATE TABLE repo_unit_template (
    templateid INT  NOT NULL,   -- from @template(id: …)

    name       TEXT NOT NULL,   -- type name

    CONSTRAINT repo_unit_template_pk
        PRIMARY KEY (templateid),
    CONSTRAINT repo_unit_template_name_uq
        UNIQUE (name)
)
;

CREATE TABLE repo_template_elements (
    templateid INT  NOT NULL,   -- from @template(id: …)
    attrid     INT  NOT NULL,   -- global attribute id

    alias      TEXT NOT NULL,   -- field name inside unit (template)
    idx        INT  NOT NULL,   -- order / display position

    CONSTRAINT repo_template_elements_pk
        PRIMARY KEY (templateid, attrid),
    CONSTRAINT repo_template_elements_tmp_ex
        FOREIGN KEY (templateid) REFERENCES repo_unit_template (templateid)
)
;

---------------------------------------------------------------
-- Metadata-table: Template for compound objects
--
CREATE TABLE repo_compound_template (
    compound_attrid  INT  NOT NULL,      -- id of the COMPOUND attribute
    idx              INT  NOT NULL,

    child_attrid     INT  NOT NULL,      -- sub-attribute
    alias            TEXT NULL,
    required         BOOLEAN NOT NULL DEFAULT FALSE,

    CONSTRAINT repo_compound_template_pk
        PRIMARY KEY (compound_attrid, idx),
    CONSTRAINT repo_compound_template_attr_ex
        FOREIGN KEY (compound_attrid)
            REFERENCES repo_attribute(attrid)
)
;


---------------------------------------------------------------
-- Attribute value vectors
--
-- String values
--
CREATE TABLE repo_string_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value (serial)
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      TEXT,

    CONSTRAINT repo_string_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_string_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

-- Considering removing
CREATE INDEX repo_sv_ind1 ON repo_string_vector (
     LOWER(val) ASC
)
;

CREATE INDEX repo_sv_ind2 ON repo_string_vector (
     valueid ASC, LOWER(val) ASC
)
;


-- Considering... for ILIKE '%foo%' searches
-- CREATE EXTENSION IF NOT EXISTS pg_trgm;
--
-- CREATE INDEX repo_sv_val_trgm ON repo_string_vector
--     USING gin (lower(val) gin_trgm_ops);

-- Considering attribute-targeted partial indexes, e.g. attribute "dc:title" with attrid = 1
-- CREATE INDEX repo_sv_title_trgm ON repo_string_vector
--    USING gin (lower(val) gin_trgm_ops)
--    WHERE valueid IN (SELECT valueid FROM repo_attribute_value WHERE attrid = 1);

--
-- Date values
--
CREATE TABLE repo_time_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      TIMESTAMP,

    CONSTRAINT repo_time_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_time_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

-- Relevant for range scans (x <= ?)
CREATE INDEX repo_tiv_ind1 ON repo_time_vector (
     val ASC
)
;

--
-- Integer values
--
CREATE TABLE repo_integer_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      INT    ,

    CONSTRAINT repo_integer_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_integer_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

--
-- Long values
--
CREATE TABLE repo_long_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      BIGINT,

    CONSTRAINT repo_long_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_long_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

--
-- Double values
--
CREATE TABLE repo_double_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      DOUBLE PRECISION,

    CONSTRAINT repo_double_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_double_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

--
-- Boolean values
--
CREATE TABLE repo_boolean_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      BOOLEAN,

    CONSTRAINT repo_boolean_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_boolean_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

--
-- Binary values
--
CREATE TABLE repo_data_vector (
    valueid  BIGINT NOT NULL,           -- id of attribute value
    idx      INT    NOT NULL DEFAULT 0, -- index of value

    val      BYTEA,

    CONSTRAINT repo_data_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_data_v_value_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

--
-- Compound values
-- TODO: Considering adding ref_attrid to PK, if the same sub-vector appears more than once in parent.
CREATE TABLE repo_compound_vector (
    valueid     BIGINT NOT NULL,           -- parent value vector
    idx         INT    NOT NULL DEFAULT 0, -- position within parent

    ref_attrid  INT    NOT NULL,
    ref_valueid BIGINT NULL,               -- initially null when first written, later updated

    CONSTRAINT repo_compound_vector_pk
        PRIMARY KEY (valueid, idx),
    CONSTRAINT repo_compound_vec_parent_ex
        FOREIGN KEY (valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE,
    CONSTRAINT repo_compound_vec_child_ex
        FOREIGN KEY (ref_valueid) REFERENCES repo_attribute_value(valueid) ON DELETE CASCADE
)
;

-- Relevant when resolving placeholders (child -> parent),
-- i.e. when querying "WHERE ref_valueid = ?child?"
CREATE INDEX repo_cv_ind1 ON repo_compound_vector (
    ref_valueid
) WITH (fillfactor = 80) -- 80-90% is a reasonable starting point for ensuring enough head-room for page splits during steady ingest
;


-- Relevant when deleting a child, validating schema, adding a composite
CREATE INDEX repo_cv_ind2 ON repo_compound_vector (
    valueid, ref_attrid
);


---------------------------------------------------------------
-- The log
--
CREATE TABLE repo_log (
    tenantid  INT       NOT NULL,
    unitid    BIGINT    NOT NULL,
    event     INT       NOT NULL, -- defined in org.gautelis.repo.model.ActionEvent
    logentry  TEXT      NOT NULL,
    logtime   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
)
;

-- When searching for all events for a certain unit
CREATE INDEX repo_log_ind1 ON repo_log (
    tenantid, unitid
)
;



---------------------------------------------------------------
-- Unit locks
--
-- The 'type' may have one of these values
--   1 - read lock
--   2 - existence lock
--   3 - write lock
--
-- Severity/guarantee: 1 < 2 < 3
--
CREATE TABLE repo_lock (
    tenantid INT        NOT NULL,
    unitid   BIGINT     NOT NULL,
    lockid   BIGINT GENERATED ALWAYS AS IDENTITY,

    purpose  TEXT       NOT NULL,
    locktype INT        NOT NULL,
    expire   TIMESTAMP,
    locktime TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT repo_lock_pk
        PRIMARY KEY (tenantid, unitid, lockid),
    CONSTRAINT repo_lock_unit_exists
        FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit (tenantid, unitid) ON DELETE CASCADE
)
;


----------------------------------------------------------------
-- Associations functionality
--
-- Internal associations describe associations between units
-- (of various types) in the archive.
--
-- External associations describe associations between a unit
-- and a resource in any external system where the resource is
-- uniquely identified by a string.
--
CREATE TABLE repo_internal_assoc (
    tenantid      INT    NOT NULL,
    unitid        BIGINT NOT NULL,
    assoctype     INT    NOT NULL,
    assoctenantid INT    NOT NULL,
    assocunitid   BIGINT NOT NULL,

    CONSTRAINT repo_internal_assoc_pk
        PRIMARY KEY (tenantid, unitid, assoctype, assoctenantid, assocunitid),
    CONSTRAINT repo_ia_left_unit_exists
        FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit (tenantid, unitid) ON DELETE CASCADE,
    CONSTRAINT repo_ia_right_unit_exists
        FOREIGN KEY (assoctenantid, assocunitid) REFERENCES repo_unit (tenantid, unitid) ON DELETE CASCADE
)
;

CREATE INDEX repo_iassoc_idx1 ON repo_internal_assoc (
     assoctype, assoctenantid, assocunitid
)
;

CREATE INDEX repo_iassoc_idx2 ON repo_internal_assoc (
     tenantid, unitid, assoctype
)
;

CREATE TABLE repo_external_assoc (
    tenantid    INT    NOT NULL,
    unitid      BIGINT NOT NULL,
    assoctype   INT    NOT NULL,
    assocstring TEXT   NOT NULL,

    CONSTRAINT repo_external_assoc_pk
        PRIMARY KEY (tenantid, unitid, assoctype, assocstring),
    CONSTRAINT repo_ea_left_unit_exists
        FOREIGN KEY (tenantid, unitid) REFERENCES repo_unit (tenantid, unitid) ON DELETE CASCADE
)
;

CREATE INDEX repo_eassoc_idx1 ON repo_external_assoc (
     assoctype, assocstring
)
;

CREATE INDEX repo_eassoc_idx2 ON repo_external_assoc (
     tenantid, unitid, assoctype
)
;
